*** Begin Patch
*** Update File: backend/src/futuresboard/binance_ws_client.py
@@
-def start_stream_worker(pairs: List[str]):  # Sync – no async
-    global retry_count
-    streams = [f"{p.lower()}@markPrice@1s" for p in pairs]
-    streams += [f"{p.lower()}@openInterest@1h" for p in pairs]
-    url = BINANCE_WS_BASE + "/".join(streams)
-    exchange = binance({"options": {"defaultType": "future"}})
-    retry_count = 0
-    while retry_count < max_retries:
-        try:
-            logger.info(f"Connected to {url}")  # Once
-            ws = exchange.ws_connect(url)
-            while True:
-                msg = ws.receive_json()
-                handle_message(msg)  # Sync
-        except Exception as e:
-            logger.warning(f"WS error: {e}; retry {retry_count + 1}/{max_retries}")
-            retry_count += 1
-            eventlet.sleep(min(2 ** retry_count, 60) + random.uniform(0, 1))  # Green sleep
-        finally:
-            if 'ws' in locals():
-                ws.close()
-    logger.error("Max retries exceeded; stopping WS stream.")
+def start_stream_worker(pairs: List[str]):  # Sync – no async
+    """
+    Start a stream worker for provided pairs. If the ccxt `binance` instance
+    exposes `ws_connect`, use it; otherwise fallback to a lightweight aiohttp
+    websocket client connecting directly to Binance public streams.
+    This avoids repeated AttributeError for ccxt builds without ws_connect.
+    """
+    global retry_count
+    streams = [f"{p.lower()}@markPrice@1s" for p in pairs]
+    streams += [f"{p.lower()}@openInterest@1h" for p in pairs]
+    url = BINANCE_WS_BASE + "/".join(streams)
+    retry_count = 0
+
+    # Try ccxt `binance` first (existing code path)
+    try:
+        exchange = binance({"options": {"defaultType": "future"}})
+    except Exception:
+        exchange = None
+
+    # If exchange provides ws_connect, use the native path.
+    if exchange is not None and hasattr(exchange, "ws_connect"):
+        while retry_count < max_retries:
+            try:
+                logger.info(f"Using ccxt ws_connect -> {url}")
+                ws = exchange.ws_connect(url)
+                while True:
+                    msg = ws.receive_json()
+                    handle_message(msg)
+            except Exception as e:
+                logger.warning(f"WS error (ccxt): {e}; retry {retry_count + 1}/{max_retries}")
+                retry_count += 1
+                eventlet.sleep(min(2 ** retry_count, 60) + random.uniform(0, 1))
+            finally:
+                if 'ws' in locals():
+                    try:
+                        ws.close()
+                    except Exception:
+                        pass
+        logger.error("Max retries exceeded for ccxt ws_connect; exiting WS worker.")
+        return
+
+    # Fallback: use aiohttp to connect to Binance public websocket URL
+    import asyncio, aiohttp
+
+    async def _aio_ws_loop(aurl):
+        global retry_count
+        session = aiohttp.ClientSession()
+        try:
+            while retry_count < max_retries:
+                try:
+                    logger.info(f"[Fallback WS] connecting to {aurl}")
+                    async with session.ws_connect(aurl, heartbeat=150) as ws:
+                        retry_count = 0
+                        async for msg in ws:
+                            if msg.type == aiohttp.WSMsgType.TEXT:
+                                try:
+                                    data = json.loads(msg.data)
+                                except Exception:
+                                    continue
+                                await handle_message(data)
+                            elif msg.type == aiohttp.WSMsgType.ERROR:
+                                logger.warning(f"[Fallback WS] message error: {msg}")
+                                break
+                except Exception as e:
+                    logger.warning(f"[Fallback WS] Connection error: {e}; retry {retry_count + 1}/{max_retries}")
+                    retry_count += 1
+                    await asyncio.sleep(min(2 ** retry_count, 60) + random.uniform(0, 1))
+            logger.error("[Fallback WS] Max retries exceeded; stopping WS loop.")
+        finally:
+            try:
+                await session.close()
+            except Exception:
+                pass
+
+    # Run fallback loop in the eventlet/green-friendly way (use eventlet.spawn or threading)
+    try:
+        # If eventlet is present prefer eventlet to avoid mixing threads
+        import eventlet
+        # eventlet-friendly wrapper to run asyncio loop
+        def _run_async_loop():
+            asyncio.run(_aio_ws_loop(url))
+        eventlet.spawn_n(_run_async_loop)
+        logger.info("[Fallback WS] started aiohttp fallback via eventlet.spawn_n")
+    except Exception:
+        # Last-resort: start a daemon thread to run asyncio loop
+        import threading
+        threading.Thread(target=lambda: asyncio.run(_aio_ws_loop(url)), daemon=True).start()
+        logger.info("[Fallback WS] started aiohttp fallback via threading")
*** End Patch
